#pragma once
//C++ includes
#include <iostream>
#include <stdexcept>
#include <functional>
#include <cstdlib>
#include <map>
#include <set>
#include <algorithm>
#include <fstream>
#include <array>
#include <unordered_map>
#include <thread>

//Exposes functions to do precise timekeeping.
#include <chrono>

//GLM Defines and includes
//GLM_FORCE_RADIANS definition is necessary to make sure that functions like glm::rotate use radians as arguments
//to avoid any possible confusion.
#define GLM_FORCE_RADIANS

//The persepective proj matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
//We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FROCE_DEPTH_ZERO_TO_ONE defintion.
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include <glm/glm.hpp>

//The hash functions are defined in the gtx folder, which means that it is techniacally still an experimental
//extension to GLM. Therefore you need to define GLM_ENABLE_EXPPERTIMENTAL to use it. It means that the API could
//change with a new version of GLM in the future, but in practive the API is very stable
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/hash.hpp>

//Exposes functions that can be used to generate model transformations like glm::rotate, 
//view transformations like glm::lookat
//proj transformation like glm::perspective.
#include <glm/gtc/matrix_transform.hpp>

#define STB_IMAGE_IMPLEMENTATION
#include <stb/stb_image.h>

//Custom includes:
#include "Window.h"

#include "../Vulkan/VulkanInstance.h"
#include "../Vulkan/Surface.h"
#include "../Vulkan/PhysicalDevice.h"
#include "../Vulkan/LogicalDevice.h"
#include "../Vulkan/SwapChain.h"
#include "../Vulkan/RenderPass.h"
#include "../Vulkan/DescriptorSetLayout.h"
#include "../Vulkan/PipelineLayout.h"
#include "../Vulkan/GraphicsPipeline.h"
#include "../Vulkan/CommandPool.h"
#include "../Vulkan/Buffer2D.h"
#include "../Vulkan/Texture.h"
#include "../Vulkan/TextureSampler.h"
#include "../Vulkan/VertexBuffer.h"
#include "../Vulkan/IndexBuffer.h"
#include "../Vulkan/DescriptorPool.h"
#include "../Vulkan/Semaphore.h"
#include "../Vulkan/Fence.h"
#include "../Vulkan/DepthBuffer.h"

#include "../Help/HelperMethods.h"

#include "HelloTriangleApplication.h"

//Create different queue family specifically for transfer operatinos. It will require you the following changes:
//1) Modify QueueFamilyIndices and FindQueueFamilies to explicitly look for a queue family with the VK_QUEUE_TRANSFER bit,
//but not the VK_QUEUE_GRAPHICS_BIT.
//2) Modify CreateLogicalDevice to request a handle to the transfer queue
//3) Create a second command pool for command buffers that are submitted on the transfer queue family
//4) Change the sharingMode of resources to be VK_SHARING_MODE_CONCURRENT and specify both the graphics and transfer queue families
//5) Submit any transfer command like vkCmdCopyBuffer to the transfer queue instead of the graphics queue

//Shader stages: the shader modules that define the functionality of the programmable stages of the graphics pipeline
//Fixed-function state: all of the structures that define the fixed-functoins stages of the pipeline, like input assembly, rasterizer, viewport and color blending
//Pipeline layout: the uniform and push values referenced by the shader that can be updated at draw time
//Render pass: the attachments referenced by the pipeline stages and their usage

/*
struct UniformBufferObject
{
	glm::mat4 model;
	glm::mat4 view;
	glm::mat4 proj;
};

Vertex Shader:
layout(binding = 0) unifomr UniformBufferObject
{
	mat4 model;
	mat4 view;
	mat4 proj;
} ubo;

void main()
{
	gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0f, 1.0f);
	fragColor = inColor;
}
*/

//How to add a texture:
//Create an image object backed by device memory
//Fill it with pixels from an image file
//Create an image sampler
//Add a combined image sampler descriptor to sample colors from the texture

//One of the most common ways to transition the layout of an image is a pipeline barrier.
//Pipeline barriers are primarily used for synchrnizing access to resources, like making sure an image was
//written to before it is read, but they can also be used to transition layouts
//Barriers can additionally be used to transfer queue family ownership when using VK_SHARING_MODE_EXCLUSIVE

//To solve that images aren't drawn over each other:
//Sort all of the draw calls by depth from back to front(used for drawing transparent objects)
//Depth testing

//Possible extentions to the program:
//Push constants
//Instanced rendering
//Dynamic uniforms
//Separate images and sampler descriptors
//Pipeline cache
//Multi-threaded command buffer generation
//Multiple subpasses
//Compute shaders

//maybe put this back in the define
/*std::cout << initLog << std::endl;\
std::cout << std::string(20, '-') << std::endl << std::endl;\*/

#define FULL_CREATION(initLog, creation, initFinsishedLog)\
creation;\
std::cout << initFinsishedLog << std::endl;\
std::cout << std::string(30, '-') << std::endl << std::endl;

HelloTriangleApplication::HelloTriangleApplication()
{
	FULL_CREATION("Window being created", m_UniqueWindow = std::make_unique<Window>(WIDTH, HEIGHT, "VulkanTestProject", false), "Window created");
	FULL_CREATION("Instance being created", m_UniqueInstance = std::make_unique<VulkanInstance>(true), "Instance created");
	FULL_CREATION("Surface being created", m_UniqueSurface = std::make_unique<Surface>(m_UniqueInstance->GetInstance(), m_UniqueWindow->GetGLFWWindow()), "Surface created");
}

HelloTriangleApplication::~HelloTriangleApplication()
{
	Cleanup();
}

void HelloTriangleApplication::Run()
{
	InitializeVulkan();
	MainLoop();
}

void HelloTriangleApplication::InitializeVulkan()
{
	//Start loading model on new thread
	//needs std::ref because we're running this method on a new thread
	auto startTime = std::chrono::high_resolution_clock::now();

	std::thread t1(LoadModel, std::ref(m_Vertices),  std::ref(m_Indices), MODEL_PATH);

	

	FULL_CREATION("Physical device being created", PickPhysicalDevice(), "Physical device created");
	FULL_CREATION("Logical device being created", m_UniqueCpu = std::make_unique<LogicalDevice>(m_UniqueInstance.get(), m_UniqueGpu.get(), m_DeviceExtensions, m_ValidationLayers), "Logical device created");
	FULL_CREATION("Swapchain being created", m_UniqueSwapChain = std::make_unique<SwapChain>(m_UniqueGpu.get(), m_UniqueWindow.get(), m_UniqueSurface.get(), m_UniqueCpu.get()), "Swapchain created");
	FULL_CREATION("Swapchain image view being created", m_UniqueSwapChain->CreateImageViews(), "Swapchain image views created");
	FULL_CREATION("Renderpass being created", m_UniqueRenderPass = std::make_unique<RenderPass>(m_UniqueCpu.get(), m_UniqueSwapChain.get(), m_UniqueGpu.get()), "Renderpass created");
	FULL_CREATION("DescriptionSetLayout being created", m_UniqueDescriptorSetLayout = std::make_unique<DescriptorSetLayout>(m_UniqueCpu.get()), "DescriptionSetLayout created");
	FULL_CREATION("Graphics pipeline being created", m_UniquePipeline = std::make_unique<GraphicsPipeline>(m_UniqueCpu.get(), m_UniqueSwapChain.get(), m_UniqueRenderPass.get(), m_UniqueDescriptorSetLayout.get()), "Graphics pipeline created");
	FULL_CREATION("Command pool being created", m_UniqueCommandPool = std::make_unique<CommandPool>(m_UniqueCpu.get(), m_UniqueGpu.get()), "Command pool created");

	FULL_CREATION("RenderTarget being created", m_UniqueRenderTarget = std::make_unique<Buffer2D>(m_UniqueCpu.get(), m_UniqueCommandPool.get(), m_UniqueRenderPass.get(), m_UniqueGpu.get(),
		m_UniqueSwapChain->GetExtent().width, m_UniqueSwapChain->GetExtent().height,
		VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
		m_UniqueSwapChain->GetFormat(), VK_IMAGE_ASPECT_COLOR_BIT, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL), "Render target created");

	FULL_CREATION("Depth buffer being created", m_UniqueDepthBuffer = std::make_unique<DepthBuffer>(m_UniqueCpu.get(), m_UniqueCommandPool.get(), m_UniqueRenderPass.get(), m_UniqueGpu.get(), m_UniqueSwapChain->GetExtent().width, m_UniqueSwapChain->GetExtent().height), "Depth buffer created");
	FULL_CREATION("Frame buffers being created", m_UniqueSwapChain->CreateFrameBuffers(m_UniqueRenderPass->GetRenderPass(), m_UniqueRenderTarget->GetImageView(), m_UniqueDepthBuffer->GetBuffer()->GetImageView()), "Frame buffers created");
	FULL_CREATION("Texture being created", m_UniqueTexture = std::make_unique<Texture>(m_UniqueCpu.get(), m_UniqueGpu.get(), m_UniqueCommandPool.get()), "Texture created");
	FULL_CREATION("Sampler being created", m_UniqueSampler = std::make_unique<TextureSampler>(m_UniqueCpu.get(), m_UniqueTexture->GetSamples()), "Sampler created");

	//Wait for model to be loaded.
	std::cout << "waiting for model to be loaded.." << std::endl;
	t1.join();
	std::cout << "Model loaded\n";

	auto now = std::chrono::high_resolution_clock::now();
	std::cout << "time it took to load model: " << std::chrono::duration<float>(now - startTime).count() << " seconds" << std::endl;
	


	FULL_CREATION("Vertex buffer being created", m_UniqueVertexBuffer = std::make_unique<VertexBuffer>(m_UniqueCpu.get(), m_UniqueGpu.get(), m_UniqueCommandPool.get(), m_Vertices), "Vertex buffer created");
	FULL_CREATION("Index buffer being created", m_UniqueIndexBuffer = std::make_unique<IndexBuffer>(m_UniqueCpu.get(), m_UniqueGpu.get(), m_UniqueCommandPool.get(), m_Indices), "Index buffer created");

	FULL_CREATION("Uniform buffer being created", m_UniqueSwapChain->CreateUniformBuffer(), "Uniform buffer created");

	FULL_CREATION("Descriptor pool being created", m_UniqueDescriptorPool = std::make_unique<DescriptorPool>(m_UniqueCpu.get(), m_UniqueSwapChain->GetImages().size()), "Descriptor pool created");
	FULL_CREATION("Descriptor sets being created", m_UniqueDescriptorPool->CreateDescriptorSets(m_UniqueSwapChain.get(), m_UniqueDescriptorSetLayout.get(), m_UniqueSampler.get(), m_UniqueTexture.get()), "Descriptor sets created");
	FULL_CREATION("Command buffers being created", m_UniqueCommandPool->CreateCommandBuffers(m_UniqueRenderPass.get(), m_UniqueSwapChain.get(), m_UniqueVertexBuffer.get(), m_UniqueIndexBuffer.get(), m_UniquePipeline.get(), m_UniqueDescriptorPool->GetSets()), "Command buffers created");
	FULL_CREATION("Sync objects being created", CreateSyncObjects(), "Sync objects created");
}

void HelloTriangleApplication::MainLoop()
{
	while (!glfwWindowShouldClose(m_UniqueWindow->GetGLFWWindow()))
	{
		glfwPollEvents();
		DrawFrame();
	}

	vkDeviceWaitIdle(m_UniqueCpu->GetDevice());
}

void HelloTriangleApplication::Cleanup()
{
	glfwTerminate();
}

std::vector<VkPhysicalDevice> HelloTriangleApplication::FindGpus()
{
	uint32_t gpuCount = 0;
	vkEnumeratePhysicalDevices(m_UniqueInstance->GetInstance(), &gpuCount, nullptr);

	if (gpuCount == 0)
		throw std::runtime_error("failed to find GPUs with Vulkan support!");

	std::vector<VkPhysicalDevice> gpus(gpuCount);
	vkEnumeratePhysicalDevices(m_UniqueInstance->GetInstance(), &gpuCount, gpus.data());

	return gpus;
}

void HelloTriangleApplication::PickPhysicalDevice()
{
	std::vector<VkPhysicalDevice> gpus = FindGpus();

	if (gpus.empty())
		throw std::runtime_error("no gpus found!");

	VkPhysicalDevice pickedPhysicalDevice = VK_NULL_HANDLE;

	std::set<std::string> requiredExtensions(m_DeviceExtensions.begin(), m_DeviceExtensions.end());

	//Check all the possible gpus and disregard those who aren't suitable

	//For those who are suitable, sort from best to worst
	//Use an ordered map to automatically sort candidates by descending score
	std::multimap<int, PhysicalDevice, std::greater<int>> candidates;

	for (const VkPhysicalDevice& gpu : gpus)
	{
		PhysicalDevice physicalDevice(m_UniqueSurface.get(), gpu, requiredExtensions);

		std::cout << "Checking " << physicalDevice.GetDesc().Properties.deviceName << std::endl;

		if (physicalDevice.IsSuitable())
		{
			int score = physicalDevice.RateSuitability();

			candidates.insert(std::make_pair(score, physicalDevice));
			//break;
		}
	}

	//Check if the best candidate is suitable at all
	if (candidates.cbegin()->first > 0)
		m_UniqueGpu = std::make_unique<PhysicalDevice>(candidates.cbegin()->second);
	else
		throw std::runtime_error("failed to find a suitable GPU!");

	std::cout << "Using: " << m_UniqueGpu->GetDesc().Properties.deviceName << std::endl;
}

void HelloTriangleApplication::DrawFrame()
{
	//Wait for the frame to be finished
	//To learn more about synchrnoization through examples,
	//have a look at this extensive overview by Kronos
	//https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples#swapchain-image-acquire-and-present

	//The vkWaitForFences function takes an array of fences and wait for either any or all of them to be signaled before returning.
	//The VK_TRUE we pass here indicates that we want to wait for all fences, but in the case of a single one it obviouslt doesn't matter.
	//just like vkAcquireNExtImageKHR this function also takes a timeout. 
	vkWaitForFences(m_UniqueCpu->GetDevice(), 1, &m_InFlightFences[m_CurrentFrame]->GetFence(), VK_TRUE, std::numeric_limits<uint64_t>::max());

	//The function calls that get called in this method will return before the operations are actually finished,
	//and the order of execution is also undefined. That's unfortunate, because each of the operations depends on the previous one finishing.
	//There are two ways of synchronizing swap chain events: fences and semaphores. They're both objects that can be used
	//for coordinating operations by having one operation signal and another operation wait for a fence or semaphore to go from the unsignaled to signaled state.
	//The difference is that the state of fences can be accessed from your program using calls like vkWaitForFences and semaphores cannot be.
	//Fences are mainly designed to synchronize your aplicatoin itself with rendering operation, whereas semaphores are used to synchronize operations
	//within or across command queues.
	//We want to synchronize the queue operations of draw commands and presenation, which makes semaphores the best fit.

	//the first thing we need to do is acquire an image from the swap chain.
	uint32_t imageIndex;

	//The first 2 parameters of vkAcquireNextImageKHR are the logical device and the swap chain from which we wish to acquire an image.
	//The third parameter specifies a timeout in nanoseconds for an image to become visible.
	//using the maximum value of a 64 bit unsigned integer disables the timeout.
	//The next 2 parameters specify synchronization objects that are to be signaled when the presenation engine is finished using the image.
	//That's the point in time where we can start drawing to it. It is possible to specify a semaphore, fence or both.
	//We're going to use our m_ImageAvailableSemaphore for that purporse here.
	//The last parameter specifies a variable to output the index of the swap chain image that has become available.
	//The index refers to the VkImage in our m_SwapChainImages array. We're going to use that index to pick the right command buffer.

	VkResult result = vkAcquireNextImageKHR(m_UniqueCpu->GetDevice(), m_UniqueSwapChain->GetSwapChain(), std::numeric_limits<uint64_t>::max(), m_ImageAvailableSemaphores[m_CurrentFrame]->GetSemaphore(), VK_NULL_HANDLE, &imageIndex);

	//if the swap chain turns out to be out of date when attempting to qcquire an image,
	//then it is no longer possible to present it.
	//Therefore we should immediately recreate the swap chain and try again in the next DrawFrame call.
	//However, if we abort drawing at this point, then the fence will never have been submitted with vkQueueSubmit
	//and it'll be in an unexpected state when we try to wait for it later on.
	//We could recreate the fences as part of the swap chain recreation but it's easier to move the vkResetFences call
	if (result == VK_ERROR_OUT_OF_DATE_KHR)
	{
		RecreateSwapChain();
		return;
	}
	else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR)
		throw std::runtime_error("failed to acquire swap chain image!");

	m_UniqueSwapChain->UpdateUniformBuffer(imageIndex);

	VkSubmitInfo submitInfo = {};
	submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

	//the first 3 parameters specify which semaphores to wait on before execution begins and in which stage(s) of the pipeline to wait.
	//We want to wait with writing colors to the image untill it's available, so we're specifying the stage of the graphics pipelines
	//that writes to the color attachment. That means that theoretically the implementation can already start executing our vertex shader and such
	//while the image is not yet available, each entry in the waitStages array corresponds to the semaphore with the same index in pWaitSemaphores.
	VkSemaphore waitSemaphores[] = { m_ImageAvailableSemaphores[m_CurrentFrame]->GetSemaphore() };
	VkPipelineStageFlags waitStages[]{ VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT };
	submitInfo.waitSemaphoreCount = 1;
	submitInfo.pWaitSemaphores = waitSemaphores;
	submitInfo.pWaitDstStageMask = waitStages;

	//The next 2 parameters specify which command buffers to actually submit for execution. As mentioned earlier
	//We should submit the command buffer that binds the swap chain image we just acquired as color attachment.
	submitInfo.commandBufferCount = 1;
	submitInfo.pCommandBuffers = &m_UniqueCommandPool->GetBuffers()[imageIndex];

	//The signalSemaphoreCount and pSigneSemaphores parameters specify which semaphores to signal once the command buffer(s) have finished execution.
	//In our case we're using the m_RenderFinishedSemaphore for that purpose.
	VkSemaphore signalSemaphores[] = { m_RenderFinishedSemaphores[m_CurrentFrame]->GetSemaphore() };
	submitInfo.signalSemaphoreCount = 1;
	submitInfo.pSignalSemaphores = signalSemaphores;

	//Unlike the semaphores, we manually need to restore the fence
	//to the unsignaled state by resetting it with the vkResetFence call.
	vkResetFences(m_UniqueCpu->GetDevice(), 1, &m_InFlightFences[m_CurrentFrame]->GetFence());

	//We can now submit the command buffer to the graphics queue using vkQueueSubmit.
	//the function takes an array of VkSubmitInfo structues as argument for efficiency when the workload is much larger.
	//The last parameter references an optional fence that will be signaled when the command buffers finish execution.
	///Deprecated: We're using semaphores for synchronization, so we'll just pass a VK_NULL_HANDLE
	if (vkQueueSubmit(m_UniqueCpu->GetGraphicsQueue(), 1, &submitInfo, m_InFlightFences[m_CurrentFrame]->GetFence()) != VK_SUCCESS)
		throw std::runtime_error("failed to submit draw command buffer!");

	VkPresentInfoKHR presentInfo = {};
	presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

	//The first 2 parameters specify which semaphores to wait on before presentation can happen, just like VkSubmitInfo.
	presentInfo.waitSemaphoreCount = 1;
	presentInfo.pWaitSemaphores = signalSemaphores;

	VkSwapchainKHR swapChains[] = { m_UniqueSwapChain->GetSwapChain() };

	//The next 3 parameters specify the swap chains to present images to and the index of the image for each swap chain.
	//This will almost always be a single one.
	presentInfo.swapchainCount = 1;
	presentInfo.pSwapchains = swapChains;
	presentInfo.pImageIndices = &imageIndex;

	//There is one last optional parameter called pResults.
	//It allows you to specify an array of VkResult values to check for every individual swap chain if presentation was successful.
	//It's not necessary if you're only using a single swap chain, because you can simply use the return value of the present function.
	presentInfo.pResults = nullptr; //Optional

	//The vkQueuePresentKHR function submits the request to present an image to the swap chain.
	//We'll add error handling for both vkAcquireNextImageKHR and vkQeuuePresentKGR in the next chapter, because their failure
	//does not necessarily mean the program should terminate, unlike the functions we've seen so far
	//The vkQueuePresentKHR also return the same values as before. In this case we will also recreate the swap chain
	//if is is suboptimal, because we want the best possible result.
	result = vkQueuePresentKHR(m_UniqueCpu->GetPresentQueue(), &presentInfo);

	if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || m_FrameBufferResized)
	{
		m_FrameBufferResized = false;
		RecreateSwapChain();
	}
	else if (result != VK_SUCCESS)
		throw std::runtime_error("failed to present swap chain image!");

	//If you run your application with validation layers enabled and you monitor the memory usage of your application,
	//you may notice that is is slowly growing. The reason for this is that the applicatoin is rapidly submitting work in the DrawFrame
	//function, but doesn't actually check if any of it finishes. If the CPU is submitting work faster than the GPU can keep up with then
	//the queue will slowly fill up with work. Worse, even, is that we are reusing the m_ImageAvailableSemaphores
	//and m_RenderFinishedSemaphore for multile frames at the same time.

	//The easy way to solve this is to wait for work to finish right after submitting it, for example by using vkQueueWaitIdle.
	vkQueueWaitIdle(m_UniqueCpu->GetPresentQueue());

	//However, we are likely not optimally using the GPU in this way, because the whole graphics pipeline is only
	//used for one frame at a time right now. The stages that the current frame has already progressed through are idle and
	//could already be used for a next frame.
	m_CurrentFrame = (m_CurrentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}

//Create semaphores and fences
void HelloTriangleApplication::CreateSyncObjects()
{
	for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; ++i)
	{
		m_ImageAvailableSemaphores.push_back(std::make_unique<Semaphore>(m_UniqueCpu.get()));
		m_RenderFinishedSemaphores.push_back(std::make_unique<Semaphore>(m_UniqueCpu.get()));
		m_InFlightFences.push_back(std::make_unique<Fence>(m_UniqueCpu.get()));
	}
}

void HelloTriangleApplication::RecreateSwapChain()
{
	int width = 0;
	int height = 0;

	while (width == 0 || height == 0)
	{
		glfwGetFramebufferSize(m_UniqueWindow->GetGLFWWindow(), &width, &height);
		glfwWaitEvents();
	}

	//To make sure we don't touch any resources that are still in use,
	//We call vkDeviceWaitIdle first.
	vkDeviceWaitIdle(m_UniqueCpu->GetDevice());

	//Clean up previous objects before recreating them
	//CleanupSwapChain();

	//Recreate the swapchain itself
	//CreateSwapChain();

	//the image views need to be recreated because they are based directly on the swap chain images
	//CreateImageViews();

	//The render pass needs to be recreated because it depends on the format of the swap chain images.
	//it is rare for the swap chain image format to change during an operation like a window resize
	//but it should still be handled
	//CreateRenderPass();

	//Viewport and scissor rectangles size is speciifed during graphics pipeline creation, so the pipeline
	//also needs to be rebuilt. it is possible to avoid this by using dynamic state for the viewports and scissor rectangles.
	//CreateGraphicsPipeline();

	//CreateColorResources();

	//The resolution of the depth buffer should change when the window is resized to match the new color attachment resolution.
	//CreateDepthResources();

	//The frame buffers and command buffers also directly depend on the swap chain images.
	//CreateFrameBuffers();
	//CreateCommandBuffers();
}
